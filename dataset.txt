dataset = [['def rate_limit_check(response):\n    if response.status_code == 429:\n        logger.warning("Rate limited. Waiting 1 minute until next request.")\n        time.', '        return True\n    return False', 'sleep(60)'], 
['def make_move(self, game_id, move):\n        for move_part in move.move.li_api_move:\n            self.', '                          params={"offeringDraw": str(move.draw_offered).lower()})', 'api_post(ENDPOINTS["move"].format(game_id, move_part),'], 
['def get_event_stream(self):\n        url = urljoin(self.', '        return requests.get(url, headers=self.header, stream=True)', 'baseUrl, ENDPOINTS["stream_event"])'], 
['def get_game_stream(self, game_id):\n        url = urljoin(self.', '        return requests.get(url, headers=self.header, stream=True)', 'baseUrl, ENDPOINTS["stream"].format(game_id))'], 
['def decline_challenge(self, challenge_id, reason="generic"):\n        return self.', '                             headers={"Content-Type": "application/x-www-form-urlencoded"})', 'api_post(ENDPOINTS["decline"].format(challenge_id), data=f"reason={reason}",'], 
['def get_profile(self):\n        profile = self.api_get(ENDPOINTS["profile"])\n        self.', '        return profile', 'set_user_agent(profile["username"])'], 
['def get_ongoing_games(self):\n        ongoing_games = self.', '        return ongoing_games', 'api_get(ENDPOINTS["playing"])["nowPlaying"]'], 
['def set_user_agent(self, username):\n        self.', '        self.session.headers.update(self.header)', 'header.update({"User-Agent": f"lidraughts-bot/{self.version} user:{username}"})'], 
['def is_online(self, user_id):\n        user = self.', '        return user and user[0].get("online")', 'api_get(ENDPOINTS["status"], params={"ids": user_id})'],
['def reset_connection(self):\n        self.session.close()\n        self.', '        self.session.headers.update(self.header)', 'session = requests.Session()'], 
['def first_search(self, board, movetime, draw_offered):\n        # No pondering after the first move since a different clock is used afterwards.', '        return self.search_for(board, movetime, draw_offered)', ''], 
['def add_go_commands(self, time_limit):\n        movetime = self.go_commands.get("movetime")\n        if movetime is not None:\n            movetime_sec = float(movetime) / 1000\n            if time_limit.', '                time_limit.movetime = movetime_sec\n        time_limit.depth = self.go_commands.get("depth")\n        time_limit.nodes = self.go_commands.get("nodes")\n        return time_limit', 'movetime is None or time_limit.movetime > movetime_sec:'], 
['def offer_draw_or_resign(self, result, board):\n        def actual(score):\n            if "cp" in score:\n                return score.get("cp", float("nan"))\n            else:\n                win = score.', '                if win > 0:\n                    return 10000 - win\n                else:\n                    return -10000 - win', 'get("win", float("nan"))'], 
['def process_playresult(self, board, result):\n        self.last_move_info = result.info.copy()\n        self.move_commentary.append(self.last_move_info.copy())\n        if self.comment_start_index is None:\n            self.comment_start_index = len(board.move_stack)\n        self.', '        result = self.offer_draw_or_resign(result, board)\n        self.last_move_info["ponderpv"] = self.last_move_info.get("pv", "")[1:-1].split()\n        self.print_stats()\n        return result', 'scores.append(self.last_move_info.get("score", {"win": 1}))'], 
['def add_null_comment(self):\n        if self.', '            self.move_commentary.append(None)', 'comment_start_index is not None:'], 
['def print_stats(self):\n        for line in self.', '            logger.info(line)', 'get_stats():'], 
['def search(self, board, time_limit, ponder, draw_offered):\n        time_limit = self.add_go_commands(time_limit)\n        result = self.', '        return self.process_playresult(board, result)', 'engine.play(board, time_limit, ponder=ponder)'], 
['def search(self, board, time_limit, ponder, draw_offered):\n        if ponder:\n            return draughts.engine.PlayResult(None, None)\n        time_limit = self.', '        result = self.engine.play(board)\n        return self.process_playresult(board, result)', 'add_go_commands(time_limit)'], 
['def search(self, board, time_limit, ponder, draw_offered):\n        if ponder:\n            return draughts.engine.PlayResult(None, None)\n        time_limit = self.', '        result = self.engine.play(board, time_limit)\n        return self.process_playresult(board, result)', 'add_go_commands(time_limit)'], 
['def signal_handler(signal, frame):\n    global terminated\n    logger.', '    terminated = True', 'debug("Recieved SIGINT. Terminating client.")'], 
['def upgrade_account(li):\n    if li.', '        return False', 'upgrade_to_bot_account() is None:'], 
['def do_correspondence_ping(control_queue, period):\n    while not terminated:\n        time.', '        control_queue.put_nowait({"type": "correspondence_ping"})', 'sleep(period)'], 
['def logging_configurer(level, filename):\n    console_handler = RichHandler()\n    console_formatter = logging.', '    console_handler.setFormatter(console_formatter)\n    all_handlers = [console_handler]', 'Formatter("%(message)s")'], 
['def game_logging_configurer(queue, level):\n    if sys.platform == "win32":\n        h = logging.handlers.QueueHandler(queue)\n        root = logging.', '        root.handlers.clear()\n        root.addHandler(h)\n        root.setLevel(level)', 'getLogger()'], 
['def choose_move_time(engine, board, search_time, draw_offered):\n    logger.', '    return engine.search_for(board, search_time, draw_offered)', 'info(f"Searching for time {search_time}")'], 
['def choose_move(engine, board, game, draw_offered, start_time, move_overhead, move_overhead_inc):\n    pre_move_time = int((time.perf_counter_ns() - start_time) / 1e6)\n    overhead = pre_move_time + move_overhead\n    wb = "w" if board.whose_turn() == draughts.WHITE else "b"\n    game.', '    game.state[f"{wb}inc"] = max(0, game.state[f"{wb}inc"] - move_overhead_inc)\n    logger.info("Searching for wtime {wtime} btime {btime}".format_map(game.state))\n    return engine.search_with_ponder(board, game.state["wtime"], game.state["btime"], game.state["winc"],\n                                     game.state["binc"], False, draw_offered)', 'state[f"{wb}time"] = max(0, game.state[f"{wb}time"] - overhead)'],
['def start_pondering(engine, board, game, can_ponder, best_move, start_time, move_overhead, move_overhead_inc):\n    if not can_ponder or best_move.', '        return None, None', 'ponder is None:'], 
['def ponder_thread_func(game, engine, board, wtime, btime, winc, binc):\n        global ponder_results\n        best_move = engine.', '        ponder_results[game.id] = best_move', 'search_with_ponder(board, wtime, btime, winc, binc, True, False)'], 
['def fake_thinking(config, board, game):\n    if config.get("fake_think_time") and len(board.move_stack) > 9:\n        delay = min(game.clock_initial, game.my_remaining_seconds()) * 0.015\n        accel = 1 - max(0, min(100, len(board.', '        sleep = min(5, delay * accel)\n        time.sleep(sleep)', 'move_stack) - 20)) / 150'], 
['def print_move_number(board):\n    logger.', '    logger.info(f"move: {len(board.move_stack) // 2 + 1}")', 'info("")'], 
['def tell_user_game_result(game, board):\n    winner = game.', '    termination = game.state.get("status")', 'state.get("winner")'], 
['def intro():\n    return fr"""\n    .   _/|\n    .  // o\\\n    .', '    .  //__\\\n    .  )___(   Play on Lidraughts with a bot\n    """', '  || ._)  lidraughts-bot {__version__}'], 
['def start_lichess_bot():\n    parser = argparse.ArgumentParser(description="Play on Lidraughts with a bot")\n    parser.add_argument("-u", action="store_true", help="Upgrade your account to a bot account.")\n    parser.', '    parser.add_argument("--config", help="Specify a configuration file (defaults to ./config.yml)")\n    parser.add_argument("-l", "--logfile", help="Record all console output to a log file.", default=None)\n    args = parser.parse_args()', 'add_argument("-v", action="store_true", help="Make output more verbose. Include all communication with lichess.")']]
